from intellecto import Intellectoimport numpy as npimport gcimport warningswarnings.filterwarnings("ignore")class ChallengeSimulator:    def __init__(self):        self.I = Intellecto()    def simulate_challenge_game(self, model, ipca, queue_size, predict_method=None, difficulty=None, verbose=False):        player_score = 0        cpu_score = 0        player_turn = True        game_over = False        game_won_by_player = False        board, queue = self.I.reset_game(queue_size=queue_size)        while not game_over:            if verbose:                print("\n\nBoard:", board)                print("Queue:", queue)                print("Players turn:", player_turn)            if player_turn:                f = self.I.one_hot_board(b=board, q=queue)                if ipca is not None:                    f = ipca.transform(f)                if predict_method == None: preds = model.predict(f).flatten().tolist()                else: preds = predict_method(model=model, x=f, one_hot=True).flatten().tolist()                move = self.I.choose_a_move(board=board, raw_moves_scores=preds)                valid_move, board_, queue_, raw_move_score = self.I.play_move(move, board, queue)                if verbose: print("Player popped #" + str(move) + " . Points gained:" + str(raw_move_score))                player_score += raw_move_score            else:                move, board_, queue_, moves_score, raw_move_score, raw_moves_score = self.I.play_a_move_on_board(board,                                                                                                            queue,                                                                                                            difficulty=difficulty)                if verbose: print("Player popped #" + str(move) + " . Points gained:" + str(raw_move_score))                cpu_score += raw_move_score            if verbose: print("PLAYER: " + str(player_score) + " || CPU: " + str(cpu_score))            board = board_            queue = queue_            game_over = self.I.is_game_over(board=board)            player_turn = not player_turn        game_won_by_player = player_score > cpu_score        return player_score, cpu_score, game_won_by_player, difficulty    def simulate_challenge_games(self, model, ipca, predict_method=None, games_per_difficulty=100, queue_size=None, verbose=False):        if queue_size is None: queue_size = self.I.queue_size        win_ratio_per_difficulties = []        for difficulty in range(self.I.n_diificulties):            games_won_by_player = 0.0            for n_game in range(games_per_difficulty):                if verbose: print("\n\n\nGame #" + str(n_game) + " for difficulty " + str(difficulty))                player_score, cpu_score, game_won_by_player, difficulty = self.simulate_challenge_game(model=model,                                                                                                       predict_method=predict_method,                                                                                                       ipca=ipca,                                                                                                       queue_size=queue_size,                                                                                                       difficulty=difficulty,                                                                                                       verbose=verbose)                if game_won_by_player: games_won_by_player += 1            win_ratio_per_difficulties.append(games_won_by_player / games_per_difficulty)            gc.collect()        win_ratio_mean = np.mean(win_ratio_per_difficulties)        return win_ratio_mean, win_ratio_per_difficulties